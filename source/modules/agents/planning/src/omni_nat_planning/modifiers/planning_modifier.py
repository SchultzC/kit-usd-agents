## Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.
##
## NVIDIA CORPORATION and its licensors retain all intellectual property
## and proprietary rights in and to this software, related documentation
## and any modifications thereto.  Any use, reproduction, disclosure or
## distribution of this software and related documentation without an express
## license agreement from NVIDIA CORPORATION is strictly prohibited.
##

import re
from typing import Any, Dict
from langchain_core.messages import AIMessage, HumanMessage
from lc_agent import (
    MultiAgentNetworkNode,
    NetworkModifier,
    RunnableHumanNode,
    RunnableNetwork,
    RunnableSystemAppend,
    RunnableAppend,
    get_node_factory,
)
from lc_agent.utils.multi_agent_utils import get_routing_tools_info
from pathlib import Path


# Helper function to read markdown files
def read_md_file(file_path: str):
    with open(file_path, "r") as file:
        return file.read()


# Get the system prompts directory
SYSTEM_PATH = Path(__file__).parent.parent.joinpath("nodes", "systems")

# Load the planning tools system prompt
PLAN_TOOLS_SYSTEM_PATH = SYSTEM_PATH.joinpath("planning_tools_system.md")
PLAN_TOOLS_SYSTEM = read_md_file(str(PLAN_TOOLS_SYSTEM_PATH))

# Plan instruction message format
# This format string controls how plan instructions are formatted when injected into the conversation
# Variables available:
#   {step_number} - The current step number
#   {step_title} - The title/description of the step
#   {step_details} - The detailed instructions for the step (newline-separated)
PLAN_INSTRUCTION_FORMAT = (
    "(Please follow the plan and respond the next action. "
    'Either "<tool_name> <question>" or "FINAL <answer>". '
    "Step {step_number}: {step_title}{step_details})"
)

# Alternative format examples:
# PLAN_INSTRUCTION_FORMAT = "**Step {step_number}**: {step_title}\n{step_details}"
# PLAN_INSTRUCTION_FORMAT = "Let's proceed with step {step_number} - {step_title}. {step_details}"
# PLAN_INSTRUCTION_FORMAT = "[PLAN] Step {step_number}: {step_title}\nDetails:\n{step_details}"


# Plan details request message
# This message is used when the planning system needs to provide more details for a specific step
# It instructs the planning agent on how to respond when asked for step details
PLAN_DETAILS_SYSTEM = """You are being asked to explain how to do a specific step from the plan.

Here's what you need to do:

1. Give a short answer - just a few sentences
2. Use simple words that anyone can understand
3. Get straight to the point - no long introductions
4. Only talk about the actions needed for this step
5. Be specific about what to do

Things to avoid:
- Don't reprint the whole plan
- Don't say things like "To execute Step 1" or "For this step"
- Don't use complex technical words when simple ones work
- Don't give long explanations

Just tell them what to do in the simplest way possible. Think of it like giving quick directions to a friend."""


class PlanningModifier(NetworkModifier):
    """
    Modifier that processes and enhances planning responses.

    This modifier handles two main workflows:
    
    1. Plan Generation and Sharing:
       - Captures plans generated by PlanningGenNode
       - Validates and extracts plan structure
       - Shares plans with MultiAgentNetworkNode for execution
       - Tracks plan execution status
    
    2. Plan Execution Guidance:
       - Injects step-by-step instructions to guide the supervisor
       - Provides tools information to the planning node
       - Handles dynamic detail generation for plan steps
    
    The modifier operates across different network types:
    - PlanningNetworkNode: Where plans are generated
    - MultiAgentNetworkNode: Where plans are executed
    """

    def __init__(self):
        super().__init__()
        self.current_plan = None
        self.plan_status = {}

    def _find_planning_and_multi_agent_networks(self, current_network):
        """
        Find the planning network node and multi-agent network node from active networks.
        
        The multi-agent network is always the next network after the planning network
        in the active networks stack.
        
        Returns:
            tuple: (planning_network_node, multi_agent_network_node) or (None, None)
        """
        active_networks = list(RunnableNetwork.get_active_networks())
        planning_network_node = None
        multi_agent_network_node = None
        
        for it_network in active_networks:
            if it_network is current_network:
                # Found the planning network node, mark it
                planning_network_node = it_network
                continue
            if planning_network_node is not None:
                # The next network after planning is the multi-agent network
                multi_agent_network_node = it_network
                break
                
        return planning_network_node, multi_agent_network_node

    def _get_tools_system_message(self, network):
        """
        Get the tools system message for the given network.
        
        Returns:
            str: The formatted tools system message
        """
        tools_descriptions, tool_call_formats, example_tool_name = get_routing_tools_info(network, False, ["planning"])
        return PLAN_TOOLS_SYSTEM.replace("<tools>", tools_descriptions)

    def _format_plan_for_context(self, plan):
        """
        Format the plan into a readable string for context.
        
        Args:
            plan: The plan dictionary with title and steps
            
        Returns:
            str: Formatted plan string
        """
        formatted_plan = f"PLAN: {plan['title']}\n\n"
        
        for step in plan['steps']:
            formatted_plan += f"Step {step['step_number']}: {step['title']}\n"
            if step.get('details'):
                for detail in step['details']:
                    formatted_plan += f"- {detail}\n"
            formatted_plan += "\n"
            
        return formatted_plan.strip()

    async def on_post_invoke_async(self, network, node):
        """
        Post-invoke hook that processes plans from the PlanningGenNode.

        Args:
            network: The current network being executed
            node: The node that was just invoked
        """
        from ..nodes.planning_node import PlanningGenNode, PlanningNetworkNode

        # ============================================
        # BRANCH 1: Process plan generation from PlanningGenNode
        # This handles when the planning node has generated a plan
        # ============================================
        if (
            node.invoked
            and isinstance(node, PlanningGenNode)
            and isinstance(network, PlanningNetworkNode)
            and isinstance(node.outputs, AIMessage)
            and node.outputs.content
            and not network.get_children(node)
        ):
            # Get the active networks
            planning_network_node, multi_agent_network_node = self._find_planning_and_multi_agent_networks(network)

            # Validation - ensure we have the right network types
            if planning_network_node:
                from ..nodes.planning_node import PlanningNetworkNode
                if not isinstance(planning_network_node, PlanningNetworkNode):
                    planning_network_node = None
                    
            if multi_agent_network_node and not isinstance(multi_agent_network_node, MultiAgentNetworkNode):
                multi_agent_network_node = None

            # Extract and validate the plan from the node output
            plan_content = node.outputs.content.strip()
            if self._is_valid_plan(plan_content):
                # Store the extracted plan in multiple places for accessibility
                self.current_plan = self._extract_plan(plan_content)
                node.metadata["current_plan"] = self.current_plan
                network.metadata["current_plan"] = self.current_plan

                # Share the plan with multi-agent network if available
                if multi_agent_network_node:
                    # Check if we need to enable dynamic details addition
                    add_details = node.metadata.get("add_details", False)
                    if add_details:
                        multi_agent_network_node.metadata["plan_gen_node"] = network.default_node

                    # Share plan and register this modifier with the multi-agent network
                    multi_agent_network_node.metadata["current_plan"] = self.current_plan
                    multi_agent_network_node.add_modifier(self, once=True, priority=-1000)

                    # Initialize plan execution status tracking
                    self.plan_status = {step["step_number"]: "pending" for step in self.current_plan["steps"]}
                    multi_agent_network_node.metadata["plan_status"] = self.plan_status
                    
        # ============================================
        # BRANCH 2: Add details to plan steps on request
        # This handles when user asks for more details about a plan step
        # ============================================
        elif (
            node.invoked
            and isinstance(node, RunnableHumanNode)
            and isinstance(network, MultiAgentNetworkNode)
            and isinstance(node.outputs, HumanMessage)
            and node.metadata.get("multi_agent_classification", None) == True
            and network.metadata.get("plan_gen_node", None)
            and node.outputs.content
        ):
            # Check if we can add details to the plan
            children = network.get_children(node)
            if len(children) == 1 and children[0].outputs is None:
                planning_node_name = network.metadata.get("plan_gen_node", None)

                # Get the current plan and execution status
                plan_metadata = self._get_plan_metadata(network)
                if not plan_metadata:
                    return

                plan_status, current_plan = plan_metadata

                # Find the next pending step that needs details
                next_step_info = self._get_next_pending_step(plan_status, current_plan)
                if not next_step_info:
                    return

                current_step_number, current_step = next_step_info

                # Skip if this step already has details
                if current_step.get("details", None):
                    return

                # Create a planning node to generate step details
                with network:
                    current_step_title = current_step["title"]

                    # Create messages and system prompts for detail generation
                    # Include the full plan for context
                    formatted_plan = self._format_plan_for_context(current_plan)
                    provide_details_message = HumanMessage(
                        content=f"Here is the full plan:\n\n{formatted_plan}\n\n"
                               f"Please provide specific implementation details for Step {current_step_number}: {current_step_title}"
                    )

                    tools_system_message = self._get_tools_system_message(network)

                    # Set up the planning node with appropriate prompts
                    planning_node = get_node_factory().create_node(planning_node_name)
                    planning_node.inputs.append(RunnableSystemAppend(system_message=tools_system_message))
                    planning_node.inputs.append(RunnableSystemAppend(system_message=PLAN_DETAILS_SYSTEM))
                    planning_node.inputs.append(RunnableAppend(message=provide_details_message))
                    planning_node.parents.clear()
                    planning_node.metadata["plan_details"] = True

                    # Connect the planning node to generate details
                    children[0]._add_parent(planning_node)

    async def on_pre_invoke_async(self, network, node):
        """
        Pre-invoke hook that guides the execution to follow the plan steps.

        This method injects plan step instructions before the default node executes,
        ensuring the agent follows the established plan.
        """
        from ..nodes.planning_node import PlanningGenNode, PlanningNetworkNode

        # ============================================
        # BRANCH 1: Inject plan step instructions for supervisor
        # This guides the multi-agent supervisor to follow the plan
        # ============================================
        if (
            isinstance(network, MultiAgentNetworkNode)
            and type(node) == get_node_factory().get_registered_node_type(network.default_node)
            and not network.get_children(node)
        ):
            # It adds the follow the plan message to the superviser
            # Get the current plan and its execution status
            plan_metadata = self._get_plan_metadata(network)
            if not plan_metadata:
                return

            plan_status, current_plan = plan_metadata

            # Find the next pending step to execute
            next_step_info = self._get_next_pending_step(plan_status, current_plan)
            if not next_step_info:
                return

            current_step_number, current_step = next_step_info

            # Build the instruction message for this step
            follow_the_plan_message = self._build_step_instruction_message(current_step_number, current_step)

            # Inject the plan instruction as a parent node
            with network:
                # Inject the current step instruction
                follow_the_plan_node = RunnableHumanNode(human_message=follow_the_plan_message)
                follow_the_plan_node.parents.clear()

                node._add_parent(follow_the_plan_node)

            # Update the step status to in_progress
            plan_status[current_step_number] = "in_progress"
            
        # ============================================
        # BRANCH 2: Add tools information to planning node
        # This provides the planning node with available tools
        # ============================================
        elif (
            not node.invoked
            and isinstance(node, PlanningGenNode)
            and isinstance(network, PlanningNetworkNode)
            and node.outputs is None
            and not network.get_children(node)
        ):
            # Add the system prompt with available tools to the planning node
            # This enables the planning node to create tool-aware plans
            planning_network_node, multi_agent_network_node = self._find_planning_and_multi_agent_networks(network)

            if multi_agent_network_node is None:
                return

            system_message = self._get_tools_system_message(multi_agent_network_node)
            node.inputs.append(RunnableSystemAppend(system_message=system_message))

    def _get_plan_metadata(self, network):
        """
        Retrieve plan and status from network metadata.

        Returns:
            tuple: (plan_status, current_plan) or None if not available
        """
        plan_status = network.metadata.get("plan_status", {})
        current_plan = network.metadata.get("current_plan", {})

        if not plan_status or not current_plan:
            return None

        return plan_status, current_plan

    def _get_next_pending_step(self, plan_status, current_plan):
        """
        Find the next step that needs to be executed.

        Args:
            plan_status: Dictionary mapping step numbers to their status
            current_plan: The current execution plan

        Returns:
            tuple: (step_number, step_data) or None if no pending steps
        """
        # Find the first pending step number
        current_step_number = next(
            (step_num for step_num in plan_status.keys() if plan_status[step_num] == "pending"), None
        )

        if current_step_number is None:
            return None

        # Find the corresponding step data
        current_step = next(
            (step for step in current_plan["steps"] if step["step_number"] == current_step_number), None
        )

        if current_step is None:
            return None

        return current_step_number, current_step

    def _build_step_instruction_message(self, step_number, step_data):
        """
        Build the instruction message for a plan step using the global format template.

        Args:
            step_number: The step number
            step_data: Dictionary containing step title and details

        Returns:
            str: Formatted instruction message
        """
        # Format step details if available
        step_details = ""
        step_title = step_data["title"]
        if step_data.get("details"):
            # Add newline before details and join them with newlines
            step_details = "\n" + "\n".join(step_data["details"])

        # Format the complete message using the template
        message = PLAN_INSTRUCTION_FORMAT.format(
            step_number=step_number, step_title=step_title, step_details=step_details
        )

        return message

    def _is_valid_plan(self, content: str) -> bool:
        """
        Check if the content contains a valid plan.

        Args:
            content: The content to check

        Returns:
            bool: True if content contains a valid plan
        """
        # Check if content contains a plan header and at least one step
        plan_header = re.search(r"PLAN:\s*(.+?)(?:\n|$)", content)
        steps = re.findall(r"Step \d+:", content)
        return plan_header is not None and len(steps) > 0

    def _extract_plan(self, content: str) -> Dict[str, Any]:
        """
        Extract and structure the plan from the content.

        Args:
            content: The content containing the plan

        Returns:
            dict: Structured plan with the following format:
                {
                    "title": "Plan title",
                    "steps": [
                        {
                            "step_number": 1,
                            "title": "Step title",
                            "details": ["detail1", "detail2", ...]
                        },
                        ...
                    ]
                }
        """
        # Extract plan title
        plan_title_match = re.search(r"PLAN:\s*(.+?)(?:\n|$)", content)
        plan_title = plan_title_match.group(1).strip() if plan_title_match else "Untitled Plan"

        # Extract steps
        steps = []
        step_matches = re.finditer(r"Step (\d+):\s*(.+?)(?=\nStep \d+:|$)", content, re.DOTALL)

        for match in step_matches:
            step_number = int(match.group(1))
            step_content = match.group(2).strip()

            # Extract details from bullet points
            details = []
            for line in step_content.split("\n"):
                if line.strip().startswith("-"):
                    details.append(line.strip()[1:].strip())

            steps.append({"step_number": step_number, "title": step_content.split("\n")[0].strip(), "details": details})

        # Sort steps by step number to ensure proper ordering
        steps.sort(key=lambda x: x["step_number"])

        return {"title": plan_title, "steps": steps}
